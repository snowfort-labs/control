import { app, BrowserWindow, ipcMain, dialog } from 'electron';
import Database from 'better-sqlite3';
import { DatabaseService } from './services/database';
import { writeFileSync } from 'fs';
import { join } from 'path';
import { platform } from 'os';
import { TaskPlan, Task } from './types/engine';
import { ptyProcessManager, memoryMonitor, cleanupMemoryResources } from './utils/memory';
import { logger } from './utils/logger';
import { config } from './config';
import { SimpleEngineDetector } from './engine/simple-detection';
import {
  PathValidator,
  StringValidator,
  NumberValidator,
  EngineValidator,
  StatusValidator,
  rateLimiter,
  validateObject,
  sanitizeConfig,
} from './utils/validation';
// Removed engineStateManager - using direct updates instead

// Required node-pty import
import * as pty from 'node-pty';
logger.pty.info('node-pty loaded successfully');


// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

// Initialize services
let database: DatabaseService;

// Start memory monitoring
memoryMonitor.start();

// Simple session tracking for engine detection
const sessionEngines: { [sessionId: string]: string | null } = {};

// Simple engine detectors for each session
const sessionDetectors: { [sessionId: string]: SimpleEngineDetector } = {};

// Engine command detection patterns (simplified)
const engineCommandPatterns = [
  { regex: /(\$ )?claude(\s|$)/i, engine: 'claude' as const },
  { regex: /claude[\s-]code/i, engine: 'claude' as const },
  { regex: /(\$ )?(gemini|aistudio)(\s|$)/i, engine: 'gemini' as const },
  { regex: /(\$ )?codex(\s|$)/i, engine: 'codex' as const },
];

// Engine exit detection
function detectEngineExit(data: string): boolean {
  const exitPatterns = [
    /\/exit/i,
    /Goodbye.*Claude/i,
    /^quit$/i,
    /Goodbye.*Gemini/i,
    /^exit$/i,
    /Goodbye.*Codex/i
  ];
  
  return exitPatterns.some(pattern => pattern.test(data.trim()));
}

// Shell prompt detection
function detectShellPrompt(data: string): boolean {
  const shellPromptPatterns = [
    /^\s*[~$%>]\s+/,
    /\n[~$%>]\s+$/,
    /\(\w+\)\s+[\w@.-]+\s+[\w-]+\s+%\s*$/,
    /[\w@-]+:\s*[\w~/.-]+\s*[$%#]\s*$/
  ];
  
  return shellPromptPatterns.some(pattern => pattern.test(data));
}


// Process terminal output for engine detection with detailed logging
async function processTerminalOutput(sessionId: string, data: string): Promise<void> {
  try {
    // Get or create simple detector for this session
    if (!sessionDetectors[sessionId]) {
      sessionDetectors[sessionId] = new SimpleEngineDetector(sessionId);
    }
    
    const detector = sessionDetectors[sessionId];
    
    
    const detection = detector.processOutput(data);
    
    if (detection) {
      // Only log actual state changes
      logger.engine.info('Engine state changed', {
        engine: detection.engine,
        status: detection.status,
        dataPreview: data.replace(/\u001b/g, '\\u001b')
      }, sessionId);
      
      // Update session tracking
      sessionEngines[sessionId] = detection.engine;
      
      // Update database with simple status
      await updateSessionEngineWithNotification(sessionId, detection.engine, detection.status);
    }
    
  } catch (error) {
    logger.engine.error('Failed to process terminal output with simple detection', error as Error, { dataLength: data.length }, sessionId);
  }
}

// Update session engine and notify UI
async function updateSessionEngineWithNotification(sessionId: string, engineType: string | null, status: string): Promise<void> {
  try {
    // Update database
    const updatedSession = await updateSessionEngine(sessionId, engineType, status);
    
    // Notify all renderer windows of the update
    BrowserWindow.getAllWindows().forEach(window => {
      window.webContents.send('session:updated', updatedSession);
    });
    
    logger.engine.info('Session updated and UI notified', { engineType, status }, sessionId);
  } catch (error) {
    logger.engine.error('Failed to update session with notification', error as Error, { sessionId, engineType, status });
  }
}

// Update session with detected engine and status - returns updated session
async function updateSessionEngine(sessionId: string, engineType: string | null, status: string): Promise<any> {
  try {
    const db = new (Database as any)(database.getDatabasePath());
    const session = db.prepare('SELECT * FROM sessions WHERE id = ?').get(sessionId);
    
    if (session) {
      const updates: any = { status };
      
      // Only update active_engine if different
      const currentEngine = session.active_engine;
      if (currentEngine !== engineType) {
        updates.active_engine = engineType;
      }
      
      // Update last_active timestamp
      updates.last_active = new Date().toISOString();
      
      const updateFields = Object.keys(updates).map(key => `${key} = ?`).join(', ');
      const updateValues = Object.values(updates);
      
      db.prepare(`UPDATE sessions SET ${updateFields} WHERE id = ?`).run(...updateValues, sessionId);
      
      logger.engine.info('Session updated', { sessionId, engineType, status });

      // Get the updated session object
      const updatedSessionFromDb = db.prepare('SELECT * FROM sessions WHERE id = ?').get(sessionId) as any;
      const updatedSession = {
        ...updatedSessionFromDb,
        projectId: updatedSessionFromDb.project_id,
        engineType: updatedSessionFromDb.engine_type,
        activeEngine: updatedSessionFromDb.active_engine,
        orderIndex: updatedSessionFromDb.order_index,
        createdAt: updatedSessionFromDb.created_at,
        lastActive: updatedSessionFromDb.last_active,
      };

      db.close();
      return updatedSession;
    }
    
    db.close();
    return null;
  } catch (error) {
    logger.engine.error('Failed to update session engine', error as Error, { sessionId, engineType, status });
    throw error;
  }
}


const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 900,
    width: 1400,
    minHeight: 600,
    minWidth: 1000,
    title: 'Snowfort Desktop - AI Agent Orchestration Platform',
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: false,
      contextIsolation: true,
    },
    titleBarStyle: 'hiddenInset',
    trafficLightPosition: { x: 20, y: 20 },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // DevTools control for development
  const isDevelopment = process.env.NODE_ENV === 'development';
  const enableDevTools = process.env.ELECTRON_DISABLE_DEVTOOLS !== 'true' && process.env.SNOWFORT_MCP_MODE !== 'true';
  
  if (isDevelopment && enableDevTools) {
    mainWindow.webContents.openDevTools();
  }
  
  // Always enable remote debugging in development for testing
  if (isDevelopment) {
    mainWindow.webContents.debugger.attach('1.3');
    logger.info('APP', 'Remote debugging enabled for Playwright testing');
  }
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', async () => {
  // Initialize services
  database = new DatabaseService();
  
  // Set up IPC handlers
  setupIpcHandlers();
  
  createWindow();
  
  // Write startup state file for MCP detection
  const stateFile = join(app.getPath('userData'), 'startup-state.json');
  writeFileSync(stateFile, JSON.stringify({
    ready: true,
    timestamp: Date.now(),
    pid: process.pid,
    version: app.getVersion()
  }));
  
  logger.info('APP', 'App initialized successfully');
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// Task Analysis and GitHub Integration Helper Functions
async function analyzeTaskConflicts(projectId: string, taskIds: string[]): Promise<TaskPlan> {
  try {
    const tasks = database.getTasks(projectId);
    const selectedTasks = tasks.filter(task => taskIds.includes(task.id));
    
    if (selectedTasks.length === 0) {
      throw new Error('No tasks found for analysis');
    }

    // For now, create a basic plan structure
    // TODO: Implement AI-powered conflict analysis
    const plan = database.createTaskPlan(projectId, `Analysis Plan - ${new Date().toISOString()}`, taskIds);
    
    // Basic conflict analysis logic (to be replaced with AI analysis)
    const phases = await performBasicConflictAnalysis(selectedTasks);
    
    return database.updateTaskPlan(plan.id, { phases });
  } catch (error) {
    logger.database.error('Error analyzing task conflicts', error as Error, { projectId, taskIds });
    throw error;
  }
}

async function performBasicConflictAnalysis(tasks: Task[]): Promise<any[]> {
  // This is a placeholder for AI-powered analysis
  // For now, just group tasks into phases
  return [
    {
      id: 'phase-1',
      name: 'Phase 1 - Parallel Tasks',
      order: 0,
      parallelGroups: [
        {
          id: 'group-1',
          taskIds: tasks.map(t => t.id),
          conflictRisk: 25,
          canRunInParallel: true
        }
      ]
    }
  ];
}

async function importGitHubIssues(projectId: string, owner: string, repo: string): Promise<Task[]> {
  try {
    // TODO: Implement GitHub API integration
    // For now, return empty array
    logger.database.info('Importing GitHub issues', { projectId, owner, repo });
    return [];
  } catch (error) {
    logger.database.error('Error importing GitHub issues', error as Error, { projectId, owner, repo });
    throw error;
  }
}

// IPC Handlers for communication between main and renderer processes
function setupIpcHandlers() {
  // Rate limiting middleware
  const checkRateLimit = (event: any, operation: string): boolean => {
    const identifier = `${event.sender.id}-${operation}`;
    if (!rateLimiter.checkLimit(identifier)) {
      logger.security.warn('Rate limit exceeded for IPC operation', { operation, senderId: event.sender.id });
      return false;
    }
    return true;
  };

  // Database operations with validation and error handling
  ipcMain.handle('db:getProjects', async (event) => {
    if (!checkRateLimit(event, 'getProjects')) {
      throw new Error('Rate limit exceeded');
    }
    
    try {
      logger.database.debug('IPC: Getting projects');
      const projects = await database.getProjects();
      logger.database.debug('IPC: Returning projects', { count: projects.length });
      return projects;
    } catch (error) {
      logger.database.error('Failed to get projects', error as Error);
      throw error;
    }
  });

  ipcMain.handle('db:getOrganizations', async (event) => {
    if (!checkRateLimit(event, 'getOrganizations')) {
      throw new Error('Rate limit exceeded');
    }
    
    try {
      logger.database.debug('Getting organizations');
      return await database.getOrganizations();
    } catch (error) {
      logger.database.error('Failed to get organizations', error as Error);
      throw error;
    }
  });

  ipcMain.handle('db:getSessions', async (event, projectId?: string) => {
    if (!checkRateLimit(event, 'getSessions')) {
      throw new Error('Rate limit exceeded');
    }
    
    try {
      const validatedProjectId = projectId ? StringValidator.validate(projectId, 100, 'projectId') : undefined;
      logger.database.debug('IPC: Getting sessions', { projectId: validatedProjectId });
      const sessions = await database.getSessions(validatedProjectId);
      logger.database.debug('IPC: Returning sessions', { count: sessions.length });
      return sessions;
    } catch (error) {
      logger.database.error('Failed to get sessions', error as Error, { projectId });
      throw error;
    }
  });

  ipcMain.handle('db:createProject', async (event, name: string, path: string, orgId?: string) => {
    if (!checkRateLimit(event, 'createProject')) {
      throw new Error('Rate limit exceeded');
    }
    
    try {
      const validatedName = StringValidator.validateProjectName(name);
      const validatedPath = PathValidator.validateProjectPath(path);
      const validatedOrgId = orgId ? StringValidator.validate(orgId, 100, 'orgId') : undefined;
      
      logger.database.info('Creating project', { name: validatedName, path: validatedPath, orgId: validatedOrgId });
      return await database.createProject(validatedName, validatedPath, validatedOrgId);
    } catch (error) {
      logger.database.error('Failed to create project', error as Error, { name, path, orgId });
      throw error;
    }
  });

  ipcMain.handle('db:createSession', async (event, projectId: string, name: string, engineType?: string, initialCommand?: string) => {
    if (!checkRateLimit(event, 'createSession')) {
      throw new Error('Rate limit exceeded');
    }
    
    try {
      const validatedProjectId = StringValidator.validate(projectId, 100, 'projectId');
      const validatedName = StringValidator.validateSessionName(name);
      const validatedEngineType = EngineValidator.validateOptional(engineType);
      const validatedInitialCommand = initialCommand ? StringValidator.validate(initialCommand, 1000, 'initialCommand') : undefined;
      
      logger.database.info('Creating session', { 
        projectId: validatedProjectId, 
        name: validatedName, 
        engineType: validatedEngineType 
      });
      
      return await database.createSession(
        validatedProjectId, 
        validatedName, 
        validatedEngineType as any, 
        validatedInitialCommand
      );
    } catch (error) {
      logger.database.error('Failed to create session', error as Error, { projectId, name, engineType });
      throw error;
    }
  });

  ipcMain.handle('db:updateProject', async (event, projectId: string, updates: any) => {
    if (!checkRateLimit(event, 'updateProject')) {
      throw new Error('Rate limit exceeded');
    }
    
    try {
      const validatedProjectId = StringValidator.validate(projectId, 100, 'projectId');
      const sanitizedUpdates = validateObject(updates, {
        name: (val) => StringValidator.validateProjectName(val),
        path: (val) => PathValidator.validateProjectPath(val),
        currentBranch: (val) => StringValidator.validate(val, 100, 'currentBranch'),
        orgId: (val) => val ? StringValidator.validate(val, 100, 'orgId') : undefined,
      });
      
      logger.database.info('Updating project', { projectId: validatedProjectId, updates: sanitizedUpdates });
      return await database.updateProject(validatedProjectId, sanitizedUpdates);
    } catch (error) {
      logger.database.error('Failed to update project', error as Error, { projectId, updates });
      throw error;
    }
  });

  ipcMain.handle('db:updateSession', async (event, sessionId: string, updates: any) => {
    if (!checkRateLimit(event, 'updateSession')) {
      throw new Error('Rate limit exceeded');
    }
    
    try {
      const validatedSessionId = StringValidator.validate(sessionId, 100, 'sessionId');
      const sanitizedUpdates = validateObject(updates, {
        name: (val) => StringValidator.validateSessionName(val),
        status: (val) => StatusValidator.validate(val) as any,
        engineType: (val) => EngineValidator.validateOptional(val) as any,
        activeEngine: (val) => EngineValidator.validateOptional(val) as any,
        config: (val) => sanitizeConfig(val),
      });
      
      logger.database.info('Updating session', { sessionId: validatedSessionId, updates: sanitizedUpdates });
      return await database.updateSession(validatedSessionId, sanitizedUpdates);
    } catch (error) {
      logger.database.error('Failed to update session', error as Error, { sessionId, updates });
      throw error;
    }
  });

  ipcMain.handle('db:deleteSession', async (event, sessionId: string) => {
    if (!checkRateLimit(event, 'deleteSession')) {
      throw new Error('Rate limit exceeded');
    }
    
    try {
      const validatedSessionId = StringValidator.validate(sessionId, 100, 'sessionId');
      
      // Clean up PTY process and session tracking
      ptyProcessManager.removeProcess(validatedSessionId);
      delete sessionEngines[validatedSessionId];
      delete sessionDetectors[validatedSessionId];
      
      logger.database.info('Deleting session', { sessionId: validatedSessionId });
      return await database.deleteSession(validatedSessionId);
    } catch (error) {
      logger.database.error('Failed to delete session', error as Error, { sessionId });
      throw error;
    }
  });

  // Task operations with validation
  ipcMain.handle('task:getTasks', async (event, projectId: string) => {
    if (!checkRateLimit(event, 'getTasks')) {
      throw new Error('Rate limit exceeded');
    }
    
    try {
      const validatedProjectId = StringValidator.validate(projectId, 100, 'projectId');
      logger.database.debug('Getting tasks', { projectId: validatedProjectId });
      return await database.getTasks(validatedProjectId);
    } catch (error) {
      logger.database.error('Failed to get tasks', error as Error, { projectId });
      throw error;
    }
  });

  ipcMain.handle('task:createTask', async (event, projectId: string, title: string, body: string, options?: any) => {
    if (!checkRateLimit(event, 'createTask')) {
      throw new Error('Rate limit exceeded');
    }
    
    try {
      const validatedProjectId = StringValidator.validate(projectId, 100, 'projectId');
      const validatedTitle = StringValidator.validate(title, 200, 'title');
      const validatedBody = StringValidator.validate(body, 10000, 'body');
      const sanitizedOptions = options ? sanitizeConfig(options) : {};
      
      logger.database.info('Creating task', { projectId: validatedProjectId, title: validatedTitle });
      return await database.createTask(validatedProjectId, validatedTitle, validatedBody, sanitizedOptions);
    } catch (error) {
      logger.database.error('Failed to create task', error as Error, { projectId, title });
      throw error;
    }
  });

  ipcMain.handle('task:updateTask', async (event, taskId: string, updates: any) => {
    if (!checkRateLimit(event, 'updateTask')) {
      throw new Error('Rate limit exceeded');
    }
    
    try {
      const validatedTaskId = StringValidator.validate(taskId, 100, 'taskId');
      const sanitizedUpdates = sanitizeConfig(updates);
      
      logger.database.info('Updating task', { taskId: validatedTaskId });
      return await database.updateTask(validatedTaskId, sanitizedUpdates);
    } catch (error) {
      logger.database.error('Failed to update task', error as Error, { taskId });
      throw error;
    }
  });

  ipcMain.handle('task:deleteTask', async (event, taskId: string) => {
    if (!checkRateLimit(event, 'deleteTask')) {
      throw new Error('Rate limit exceeded');
    }
    
    try {
      const validatedTaskId = StringValidator.validate(taskId, 100, 'taskId');
      logger.database.info('Deleting task', { taskId: validatedTaskId });
      return await database.deleteTask(validatedTaskId);
    } catch (error) {
      logger.database.error('Failed to delete task', error as Error, { taskId });
      throw error;
    }
  });

  // Task planning operations
  ipcMain.handle('task:getTaskPlans', (_, projectId: string) => 
    database.getTaskPlans(projectId));
  ipcMain.handle('task:createTaskPlan', (_, projectId: string, name: string, taskIds: string[]) => 
    database.createTaskPlan(projectId, name, taskIds));
  ipcMain.handle('task:updateTaskPlan', (_, planId: string, updates: any) => 
    database.updateTaskPlan(planId, updates));
  ipcMain.handle('task:analyzeTaskConflicts', async (_, projectId: string, taskIds: string[]) => {
    // This will be implemented with AI analysis
    return analyzeTaskConflicts(projectId, taskIds);
  });

  // GitHub integration
  ipcMain.handle('task:importGitHubIssues', async (_, projectId: string, owner: string, repo: string) => {
    // This will be implemented with GitHub API
    return importGitHubIssues(projectId, owner, repo);
  });

  // File system operations with validation
  ipcMain.handle('fs:selectDirectory', async (event) => {
    if (!checkRateLimit(event, 'selectDirectory')) {
      throw new Error('Rate limit exceeded');
    }
    
    try {
      logger.ipc.debug('Showing directory selection dialog');
      const result = await dialog.showOpenDialog({
        properties: ['openDirectory'],
        title: 'Select Project Directory'
      });
      
      if (result.canceled || !result.filePaths[0]) {
        logger.ipc.debug('Directory selection canceled');
        return null;
      }
      
      const selectedPath = result.filePaths[0];
      const validatedPath = PathValidator.validate(selectedPath);
      
      logger.ipc.info('Directory selected', { path: validatedPath });
      return validatedPath;
    } catch (error) {
      logger.ipc.error('Failed to select directory', error as Error);
      throw error;
    }
  });

  
  // Test IPC
  ipcMain.handle('test:ping', () => {
    return 'pong';
  });

  // PTY operations with validation and improved error handling
  ipcMain.on('pty:start', (event, sessionId: string, projectPath: string) => {
    try {
      const validatedSessionId = StringValidator.validate(sessionId, 100, 'sessionId');
      const validatedProjectPath = PathValidator.validateProjectPath(projectPath);
      
      // Check if process already exists
      if (ptyProcessManager.getProcess(validatedSessionId)) {
        logger.pty.info('PTY process already exists', undefined, validatedSessionId);
        return;
      }
      
      // Check process limits
      const appConfig = config.get();
      if (ptyProcessManager.getProcessCount() >= appConfig.pty.maxConcurrentProcesses) {
        logger.pty.warn('Maximum PTY processes reached', { count: ptyProcessManager.getProcessCount() });
        event.sender.send(`pty:error:${validatedSessionId}`, 'Maximum processes reached');
        return;
      }

      const shell = platform() === 'win32' ? 'powershell.exe' :
                    platform() === 'darwin' ? 'zsh' :
                    'bash';
      
      // Use minimal args like the article example
      const args: string[] = [];

      // Use the configuration recommended by the article
      const ptyEnv = {
        ...process.env,
        TERM: 'xterm-256color',
      };

      const ptyProcess = pty.spawn(shell, args, {
        name: 'xterm-256color',
        cols: 80,
        rows: 24,
        cwd: validatedProjectPath,
        env: ptyEnv,
      });

      ptyProcess.onData(async (data: string) => {
        try {
          // Debug mode: Log raw output with ANSI sequences visible
          if (process.env.DEBUG_PTY === 'true') {
            const escapedData = data
              .replace(/\u001b/g, '\\u001b')
              .replace(/\r/g, '\\r')
              .replace(/\n/g, '\\n');
            logger.pty.debug(`RAW PTY DATA: ${escapedData}`, { length: data.length }, validatedSessionId);
          }
          
          
          // Process terminal output for engine detection
          await processTerminalOutput(validatedSessionId, data);
          
          // Update activity tracking
          ptyProcessManager.updateActivity(validatedSessionId);
          
          // Send data to renderer for display
          event.sender.send(`pty:data:${validatedSessionId}`, data);
        } catch (error) {
          logger.pty.error('Error processing PTY data', error as Error, undefined, validatedSessionId);
        }
      });

      ptyProcess.onExit(({ exitCode }: { exitCode: number }) => {
        try {
          logger.pty.info('PTY process exited', { exitCode }, validatedSessionId);
          
          // Reset the detector to show we're back at shell/no engine
          if (sessionDetectors[validatedSessionId]) {
            sessionDetectors[validatedSessionId].reset();
            
            // Update the session to reflect no active engine
            try {
              database.updateSession(validatedSessionId, { 
                engineType: undefined,
                status: 'ready' 
              });
              
              logger.engine.info('Session updated after PTY exit', { 
                sessionId: validatedSessionId,
                engineType: null,
                status: 'ready'
              });
              
              // Notify UI about the engine state change
              event.sender.send(`engine:state:${validatedSessionId}`, {
                engine: null,
                status: 'ready'
              });
            } catch (error) {
              logger.engine.error('Failed to update session after PTY exit', error as Error, undefined, validatedSessionId);
            }
          }
          
          event.sender.send(`pty:exit:${validatedSessionId}`, exitCode);
          ptyProcessManager.removeProcess(validatedSessionId);
          
          // Clean up session tracking
          delete sessionEngines[validatedSessionId];
          delete sessionDetectors[validatedSessionId];
        } catch (error) {
          logger.pty.error('Error handling PTY exit', error as Error, { exitCode }, validatedSessionId);
        }
      });

      // Add to process manager and initialize session tracking
      ptyProcessManager.addProcess(validatedSessionId, ptyProcess, validatedProjectPath);
      sessionEngines[validatedSessionId] = null;
      sessionDetectors[validatedSessionId] = new SimpleEngineDetector(validatedSessionId);
      
      // Start pattern capture if enabled
      if (process.env.CAPTURE_PATTERNS === 'true') {
        // Pattern capture removed - detection happens in SimpleEngineDetector
      }
      
      logger.engine.info('PTY process and session tracking initialized', undefined, validatedSessionId);
      
    } catch (error) {
      logger.pty.error('Failed to start PTY process', error as Error, { projectPath }, sessionId);
      event.sender.send(`pty:error:${sessionId}`, (error as Error).message);
    }
  });

  ipcMain.on('pty:write', async (event, sessionId: string, data: string) => {
    try {
      const validatedSessionId = StringValidator.validate(sessionId, 100, 'sessionId');
      // CRITICAL: Do NOT validate the data - it must pass through unchanged
      // Validating terminal data breaks escape sequences (e.g., arrow keys: \x1b[D)
      // The raw bytes must flow: xterm.js → IPC → node-pty → shell
      
      const ptyProcess = ptyProcessManager.getProcess(validatedSessionId);
      if (ptyProcess) {
        try {
          ptyProcess.write(data);  // Write raw data without any processing
          logger.pty.debug('Data written to PTY', { dataLength: data.length }, validatedSessionId);
          
          // Check if user typed an engine command
          const trimmedData = data.trim();
          if (trimmedData && sessionDetectors[validatedSessionId]) {
            for (const { regex, engine } of engineCommandPatterns) {
              if (regex.test(trimmedData)) {
                // User typed an engine command - set the engine type
                sessionDetectors[validatedSessionId].setEngine(engine);
                logger.engine.info('Engine command detected', { command: trimmedData, engine }, validatedSessionId);
                break;
              }
            }
          }
        } catch (error) {
          logger.pty.error('Error writing to PTY', error as Error, undefined, validatedSessionId);
          await updateSessionEngineWithNotification(validatedSessionId, null, 'error');
        }
      } else {
        logger.pty.warn('No PTY process found for session', undefined, validatedSessionId);
      }
    } catch (error) {
      logger.pty.error('Failed to validate PTY write request', error as Error, { sessionId, dataLength: data?.length });
    }
  });

  ipcMain.on('pty:resize', (event, sessionId: string, { cols, rows }: { cols: number, rows: number }) => {
    try {
      const validatedSessionId = StringValidator.validate(sessionId, 100, 'sessionId');
      const validatedDimensions = NumberValidator.validateTerminalSize(cols, rows);
      
      const ptyProcess = ptyProcessManager.getProcess(validatedSessionId);
      if (ptyProcess) {
        try {
          ptyProcess.resize(validatedDimensions.cols, validatedDimensions.rows);
          logger.pty.debug('PTY resized', validatedDimensions, validatedSessionId);
        } catch (error) {
          logger.pty.error('Error resizing PTY', error as Error, validatedDimensions, validatedSessionId);
        }
      } else {
        logger.pty.warn('No PTY process found for resize', undefined, validatedSessionId);
      }
    } catch (error) {
      logger.pty.error('Failed to validate PTY resize request', error as Error, { sessionId, cols, rows });
    }
  });

  ipcMain.on('pty:kill', async (event, sessionId: string) => {
    try {
      const validatedSessionId = StringValidator.validate(sessionId, 100, 'sessionId');
      
      if (ptyProcessManager.removeProcess(validatedSessionId)) {
        // Clean up session tracking and update database
        delete sessionEngines[validatedSessionId];
        delete sessionDetectors[validatedSessionId];
        await updateSessionEngineWithNotification(validatedSessionId, null, 'idle');
        logger.pty.info('PTY process killed', undefined, validatedSessionId);
      } else {
        logger.pty.warn('No PTY process found to kill', undefined, validatedSessionId);
      }
    } catch (error) {
      logger.pty.error('Failed to kill PTY process', error as Error, { sessionId });
    }
  });

  // Add handler to check if PTY exists for a session
  ipcMain.handle('pty:exists', async (event, sessionId: string) => {
    try {
      const validatedSessionId = StringValidator.validate(sessionId, 100, 'sessionId');
      const exists = ptyProcessManager.getProcess(validatedSessionId) !== null;
      logger.pty.debug('Checking PTY existence', { exists }, validatedSessionId);
      return exists;
    } catch (error) {
      logger.pty.error('Failed to check PTY existence', error as Error, { sessionId });
      return false;
    }
  });

  // Add handler to clear PTY terminal (send clear command)
  ipcMain.on('pty:clear', (event, sessionId: string) => {
    try {
      const validatedSessionId = StringValidator.validate(sessionId, 100, 'sessionId');
      
      const ptyProcess = ptyProcessManager.getProcess(validatedSessionId);
      if (ptyProcess) {
        try {
          ptyProcess.write('\x1b[2J\x1b[H'); // Clear screen and move cursor to top
          logger.pty.info('Terminal cleared', undefined, validatedSessionId);
        } catch (error) {
          logger.pty.error('Error clearing PTY', error as Error, undefined, validatedSessionId);
        }
      } else {
        logger.pty.warn('No PTY process found for clear', undefined, validatedSessionId);
      }
    } catch (error) {
      logger.pty.error('Failed to clear PTY', error as Error, { sessionId });
    }
  });


  // Note: Per-session state change handlers are registered when PTY processes start
  logger.engine.info('IPC handlers setup complete');
}

// Cleanup on app quit
app.on('before-quit', () => {
  try {
    logger.info('APP', 'Application shutting down, cleaning up resources');
    
    // Clean up memory resources
    cleanupMemoryResources();
    
    // Close database
    if (database) {
      database.close();
      logger.database.info('Database connection closed');
    }
    
    logger.info('APP', 'Application cleanup completed');
  } catch (error) {
    logger.error('APP', 'Error during application cleanup', error as Error);
  }
});